<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"gnehz972.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.1","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>

    <meta name="description" content="GraphQL is a flexible query language for APIs that allows clients to request specific data, receiving precisely tailored JSON responses. It uses a schema (the API’s blueprint) to define available data">
<meta property="og:type" content="article">
<meta property="og:title" content="Quick learn GraphQL basics by asking AI">
<meta property="og:url" content="https://gnehz972.github.io/posts/3a9d928e/index.html">
<meta property="og:site_name" content="gnehz972">
<meta property="og:description" content="GraphQL is a flexible query language for APIs that allows clients to request specific data, receiving precisely tailored JSON responses. It uses a schema (the API’s blueprint) to define available data">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-12-05T14:47:00.000Z">
<meta property="article:modified_time" content="2024-12-07T03:38:36.226Z">
<meta property="article:author" content="gnehz972">
<meta property="article:tag" content="AI">
<meta property="article:tag" content="GraphQL">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://gnehz972.github.io/posts/3a9d928e/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://gnehz972.github.io/posts/3a9d928e/","path":"posts/3a9d928e/","title":"Quick learn GraphQL basics by asking AI"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Quick learn GraphQL basics by asking AI | gnehz972</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/atom.xml" title="gnehz972" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">gnehz972</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Q1-what%E2%80%99s-GraphQL"><span class="nav-number">1.</span> <span class="nav-text">Q1 what’s GraphQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q2-what%E2%80%99s-tech-it-used-underneath"><span class="nav-number">2.</span> <span class="nav-text">Q2 what’s tech it used underneath</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q3-give-an-simple-illustration-of-how-GraphQL-works"><span class="nav-number">3.</span> <span class="nav-text">Q3 give an simple illustration of how GraphQL works</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q4-how-client-communicate-with-the-server"><span class="nav-number">4.</span> <span class="nav-text">Q4 how client communicate with the server</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q5-draw-a-overview-diagram-for-the-GraphQL"><span class="nav-number">5.</span> <span class="nav-text">Q5 draw a overview diagram for the GraphQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q6-list-the-core-concept-of-GraphQL"><span class="nav-number">6.</span> <span class="nav-text">Q6 list the core concept of GraphQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q7-what%E2%80%99s-needed-for-client-to-query-data"><span class="nav-number">7.</span> <span class="nav-text">Q7 what’s needed for client to query data</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q8-explain-the-grammar-in-the-query-body"><span class="nav-number">8.</span> <span class="nav-text">Q8 explain the grammar in the query body</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q9-what%E2%80%99s-the-graphQL-schema-include"><span class="nav-number">9.</span> <span class="nav-text">Q9 what’s the graphQL schema include</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q10-type-Query-vs-type-User"><span class="nav-number">10.</span> <span class="nav-text">Q10 type Query vs type User</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Q11-what%E2%80%99s-the-different-between-the-GraphQL-query-document-and-the-schema-document"><span class="nav-number">11.</span> <span class="nav-text">Q11 what’s the different between the GraphQL query document and the schema document</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">gnehz972</p>
  <div class="site-description" itemprop="description">Android/iOS/Web/BE/AI</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://gnehz972.github.io/posts/3a9d928e/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="gnehz972">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="gnehz972">
      <meta itemprop="description" content="Android/iOS/Web/BE/AI">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Quick learn GraphQL basics by asking AI | gnehz972">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Quick learn GraphQL basics by asking AI
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-12-05 22:47:00" itemprop="dateCreated datePublished" datetime="2024-12-05T22:47:00+08:00">2024-12-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-12-07 11:38:36" itemprop="dateModified" datetime="2024-12-07T11:38:36+08:00">2024-12-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Language/" itemprop="url" rel="index"><span itemprop="name">Language</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>GraphQL is a flexible query language for APIs that allows clients to request specific data, receiving precisely tailored JSON responses. It uses a schema (the API’s blueprint) to define available data and operations (queries, mutations, subscriptions). Clients communicate via HTTP POST requests to a single endpoint, and the server uses resolvers to fetch data from various sources.<br>Key concepts include SDL, types, resolvers, and the distinction between schema (server-side definition) and client queries (data requests).</p>
<p>This Q&amp;A provides a comprehensive introduction to GraphQL, covering its core concepts, architecture, and communication mechanisms.</p>
<span id="more"></span>


<h2 id="Q1-what’s-GraphQL"><a href="#Q1-what’s-GraphQL" class="headerlink" title="Q1 what’s GraphQL"></a>Q1 what’s GraphQL</h2><p>GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. It’s a modern alternative to REST and offers several advantages. Think of it as a more precise and flexible way to request data from a server.</p>
<h2 id="Q2-what’s-tech-it-used-underneath"><a href="#Q2-what’s-tech-it-used-underneath" class="headerlink" title="Q2 what’s tech it used underneath"></a>Q2 what’s tech it used underneath</h2><p>GraphQL itself is a specification, not a specific technology. It defines the query language, the schema definition language (SDL), and the execution semantics. Various server implementations use different underlying technologies to bring GraphQL to life.</p>
<h2 id="Q3-give-an-simple-illustration-of-how-GraphQL-works"><a href="#Q3-give-an-simple-illustration-of-how-GraphQL-works" class="headerlink" title="Q3 give an simple illustration of how GraphQL works"></a>Q3 give an simple illustration of how GraphQL works</h2><p>Imagine a restaurant (the <strong>GraphQL server</strong>) with a menu (the <strong>GraphQL schema</strong>). You (the <strong>GraphQL client</strong>) want to order food.</p>
<p><strong>1. The Menu (Schema):</strong></p>
<p>The menu lists all the available dishes (<strong>types</strong>), like Burger, Pizza, and Salad. Each dish has ingredients&#x2F;options (<strong>fields</strong>), like Burger has patty, cheese, and bun.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">type Burger &#123;</span><br><span class="line">  patty: String!</span><br><span class="line">  cheese: Boolean</span><br><span class="line">  bun: String!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Pizza &#123;</span><br><span class="line">  toppings: [String!]!</span><br><span class="line">  crust: String!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Query &#123;  // What you can order</span><br><span class="line">  burgerOfTheDay: Burger</span><br><span class="line">  pizza(toppings: [String!]): Pizza</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>2. Your Order (Query):</strong></p>
<p>Instead of ordering a pre-defined combo meal, you tell the waiter exactly what you want using a special order form (the <strong>GraphQL query</strong>).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query MyOrder &#123;</span><br><span class="line">  burgerOfTheDay &#123;</span><br><span class="line">    patty</span><br><span class="line">    cheese</span><br><span class="line">  &#125;</span><br><span class="line">  pizza(toppings: [&quot;pepperoni&quot;, &quot;mushrooms&quot;]) &#123;</span><br><span class="line">    crust</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>3. The Kitchen (Resolvers):</strong></p>
<p>The waiter (the <strong>GraphQL engine</strong>) takes your order form to the kitchen (<strong>resolvers</strong>). The kitchen prepares each item according to your specifications, fetching the necessary ingredients from the pantry (<strong>data sources</strong>).</p>
<p><strong>4. Your Meal (Response):</strong></p>
<p>The waiter brings you exactly what you ordered, no more, no less, on a tray (the <strong>JSON response</strong>).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123;</span><br><span class="line">    &quot;burgerOfTheDay&quot;: &#123;</span><br><span class="line">      &quot;patty&quot;: &quot;Beef&quot;,</span><br><span class="line">      &quot;cheese&quot;: true</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;pizza&quot;: &#123;</span><br><span class="line">      &quot;crust&quot;: &quot;Thin&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>Key takeaways:</strong></p>
<ul>
<li><p>You get exactly what you ask for, no more (no extra fries you didn’t want) or less (no missing ingredients).</p>
</li>
<li><p>You use one order form (single endpoint) for everything, whether it’s a burger, pizza, or anything else on the menu.</p>
</li>
<li><p>The menu tells you what’s available (schema), so you know how to create a valid order (query).</p>
</li>
</ul>
<p>This simple analogy illustrates the core principles of GraphQL: clients request specific data, the server fulfills those requests precisely based on a defined schema, and everything happens through a single endpoint. This makes GraphQL efficient, flexible, and developer-friendly.</p>
<h2 id="Q4-how-client-communicate-with-the-server"><a href="#Q4-how-client-communicate-with-the-server" class="headerlink" title="Q4 how client communicate with the server"></a>Q4 how client communicate with the server</h2><p>GraphQL clients communicate with servers primarily using HTTP, typically over a single endpoint. Here’s a breakdown of the process:</p>
<ol>
<li><p><strong>HTTP Request:</strong> The client sends an HTTP POST request to the GraphQL server’s endpoint (usually &#x2F;graphql or a similar path).</p>
</li>
<li><p><strong>Query in Body:</strong> The GraphQL query itself is sent in the request body, typically as a JSON-encoded string. The JSON structure usually looks like this:</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &quot;YOUR_GRAPHQL_QUERY&quot;,</span><br><span class="line">  &quot;`variables`&quot;: &#123;</span><br><span class="line">    &quot;variable1&quot;: &quot;value1&quot;,</span><br><span class="line">    &quot;variable2&quot;: 2</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;operationName&quot;: &quot;MyQuery&quot; // Optional</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>“query”: Contains the actual GraphQL query string.</p>
</li>
<li><p>“variables”: An optional object containing variables used in the query (parameterization). This helps avoid string interpolation and improves security.</p>
</li>
<li><p>“operationName”: Optional but recommended if you have multiple queries in a single request. It helps the server identify which query to execute.</p>
</li>
</ul>
</li>
<li><p><strong>Content-Type Header:</strong> The Content-Type header is set to application&#x2F;json to indicate the format of the request body.</p>
</li>
<li><p><strong>Server Processing:</strong></p>
<ul>
<li><p><strong>Parsing and Validation:</strong> The server receives the request, parses the GraphQL query, and validates it against the schema.</p>
</li>
<li><p><strong>Execution:</strong> If the query is valid, the server executes it using resolvers to fetch data from the appropriate data sources.</p>
</li>
<li><p><strong>Response Formatting:</strong> The server formats the response data according to the query’s structure.</p>
</li>
</ul>
</li>
<li><p><strong>HTTP Response:</strong> The server sends an HTTP response back to the client, also typically with a Content-Type of application&#x2F;json. The response body contains the requested data (or error information). A standard response format looks like this:</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;data&quot;: &#123; /* The requested data */ &#125;,</span><br><span class="line">  &quot;errors&quot;: [ /* Any errors encountered */ ] // Optional</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>“data”: Contains the data requested by the query. If the query was successful, this field will be populated.</p>
</li>
<li><p>“errors”: An optional array of errors encountered during query processing. Even if there are errors, the “data” field might still contain partial results.</p>
</li>
</ul>
</li>
</ol>
<p><strong>Alternative Transports (Less Common):</strong></p>
<p>While HTTP is the most common transport, GraphQL can technically be used over other protocols:</p>
<ul>
<li><p><strong>WebSockets:</strong> For subscriptions (real-time updates), clients and servers might use WebSockets to maintain a persistent connection.</p>
</li>
<li><p><strong>Other protocols:</strong> In theory, GraphQL could be used over other protocols, but HTTP is the standard and most widely supported.</p>
</li>
</ul>
<p><strong>Client Libraries:</strong></p>
<p>Client-side libraries like Apollo Client, Relay, and others simplify the process of making GraphQL requests and handling responses. They handle the details of constructing the HTTP request, parsing the response, and managing caching.</p>
<p>This standardized HTTP-based communication makes GraphQL relatively easy to integrate into existing web and mobile architectures. The use of a single endpoint and a clear request&#x2F;response format simplifies client development and improves API maintainability.</p>
<h2 id="Q5-draw-a-overview-diagram-for-the-GraphQL"><a href="#Q5-draw-a-overview-diagram-for-the-GraphQL" class="headerlink" title="Q5 draw a overview diagram for the GraphQL"></a>Q5 draw a overview diagram for the GraphQL</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+-----------------+     +----------------+     +-----------------+</span><br><span class="line">| GraphQL Client  |----&gt;| GraphQL Server |----&gt;|  Data Sources   |</span><br><span class="line">+-----------------+     +----------------+     +-----------------+</span><br><span class="line">        ^                       |                       |</span><br><span class="line">        |                       |                       |</span><br><span class="line">        |                       v                       |</span><br><span class="line">        |               +-----------+                   |</span><br><span class="line">        |               |   Schema  |                   |</span><br><span class="line">        |               +-----------+                   |</span><br><span class="line">        |                       |                       |</span><br><span class="line">        |       +-----------------------+               |</span><br><span class="line">        |       | Query/Mutation/Subscr |               |  </span><br><span class="line">        |       +-----------------------+               |</span><br><span class="line">        |                       |                       |</span><br><span class="line">        |    +-----------------------------+            |</span><br><span class="line">        +----| JSON Response (data/errors) |------------+</span><br><span class="line">             +-----------------------------+ </span><br></pre></td></tr></table></figure>

<p><strong>Explanation of Components:</strong></p>
<ul>
<li><p><strong>GraphQL Client:</strong> Sends queries, mutations, and subscriptions to the server. Can be a web browser, mobile app, or any other application.</p>
</li>
<li><p><strong>GraphQL Server:</strong> Receives requests from the client, validates them against the schema, executes resolvers, and returns data (or errors) in JSON format.</p>
</li>
<li><p><strong>Data Sources:</strong> Databases, REST APIs, microservices, or any other source of data that the GraphQL server interacts with.</p>
</li>
<li><p><strong>Schema:</strong> The central definition of the API. It specifies the types, fields, queries, mutations, and subscriptions available.</p>
</li>
<li><p><strong>Query&#x2F;Mutation&#x2F;Subscription:</strong> The operations sent by the client to request or modify data, or to subscribe to real-time updates.</p>
</li>
<li><p><strong>JSON Response (data&#x2F;errors):</strong> The server’s response to the client’s request, containing the requested data or error information in JSON format. The response always includes a “data” key (which might be null if there was an error) and may optionally include an “errors” key if any errors occurred.</p>
</li>
</ul>
<h2 id="Q6-list-the-core-concept-of-GraphQL"><a href="#Q6-list-the-core-concept-of-GraphQL" class="headerlink" title="Q6 list the core concept of GraphQL"></a>Q6 list the core concept of GraphQL</h2><ol>
<li><p><strong>Schema Definition Language (SDL):</strong> GraphQL uses a strongly typed schema to define the data available from the server. This schema acts as a contract between the client and the server. It uses SDL to define types, fields, queries, mutations, and subscriptions.</p>
</li>
<li><p><strong>Queries:</strong> The client uses queries to request specific data from the server. Queries resemble the structure of the data they request, allowing clients to fetch only the necessary information.</p>
</li>
<li><p><strong>Mutations:</strong> Mutations are used to modify data on the server (create, update, delete). Like queries, mutations have a defined structure and return specific data after the modification.</p>
</li>
<li><p><strong>Subscriptions:</strong> Subscriptions enable real-time communication between the client and the server. Clients can subscribe to specific events or data changes and receive updates as they happen.</p>
</li>
<li><p><strong>Resolvers:</strong> Resolvers are functions on the server that fetch the data for each field in the schema. They connect the GraphQL query to the underlying data sources (databases, APIs, etc.).</p>
</li>
<li><p><strong>Types:</strong> GraphQL schemas are built around types. Scalar types (Int, String, Boolean, Float, ID) represent primitive data, while object types define entities with fields.</p>
</li>
<li><p><strong>Fields:</strong> Fields are properties of types that represent the data that can be queried or mutated. Each field has a specific type.</p>
</li>
<li><p><strong>Arguments:</strong> Arguments are parameters passed to queries, mutations, and subscriptions to refine the request. They allow clients to filter, sort, or paginate data.</p>
</li>
<li><p><strong>Variables:</strong> Variables allow you to parameterize queries and mutations, making them more reusable and avoiding string interpolation. They are passed separately from the query string.</p>
</li>
<li><p><strong>Fragments:</strong> Fragments are reusable units of GraphQL code that allow you to select a set of fields from a type. They help avoid redundancy and improve code organization.</p>
</li>
<li><p><strong>Introspection:</strong> GraphQL allows clients to introspect the server’s schema, discovering the available types, fields, and operations. This enables powerful tooling and dynamic query building.</p>
</li>
</ol>
<h2 id="Q7-what’s-needed-for-client-to-query-data"><a href="#Q7-what’s-needed-for-client-to-query-data" class="headerlink" title="Q7 what’s needed for client to query data"></a>Q7 what’s needed for client to query data</h2><p>For a client to query data from a GraphQL server, several things are required:</p>
<ol>
<li><p><strong>GraphQL Endpoint:</strong> The client needs to know the URL of the GraphQL server’s endpoint. This is usually a single endpoint (often &#x2F;graphql) that handles all GraphQL requests (queries, mutations, and subscriptions).</p>
</li>
<li><p><strong>Query Document:</strong> The client must construct a GraphQL query document. This document specifies the data the client wants to fetch, including the fields, arguments, and any nested objects.</p>
</li>
<li><p><strong>HTTP Request (Usually POST):</strong> The client typically sends an HTTP POST request to the GraphQL endpoint.</p>
</li>
<li><p><strong>Query in Request Body (JSON):</strong> The GraphQL query document is included in the body of the HTTP request, usually encoded as a JSON string. The JSON structure typically looks like this:</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &quot;YOUR_GRAPHQL_QUERY_HERE&quot;,</span><br><span class="line">  &quot;variables&quot;: &#123; /* optional variables */ &#125;,</span><br><span class="line">  &quot;operationName&quot;: &quot;MyQuery&quot; // Optional for multiple queries</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>“query”: The string containing your GraphQL query.</p>
</li>
<li><p>“variables”: (Optional) An object containing variables used in the query. This is good practice to parameterize queries.</p>
</li>
<li><p>“operationName”: (Optional, but recommended for clarity) If you have multiple operations (queries, mutations) in a single request, operationName specifies which one to execute.</p>
</li>
</ul>
</li>
<li><p><strong>Content-Type Header:</strong> The Content-Type header of the HTTP request should be set to application&#x2F;json to indicate the format of the request body.</p>
</li>
<li><p><strong>(Optional) Client-Side Library:</strong> While not strictly required, using a client-side GraphQL library (like Apollo Client, Relay, or urql) is highly recommended. These libraries simplify the process of making GraphQL requests, handling responses, caching, and managing subscriptions. They abstract away the low-level details of HTTP requests and JSON encoding.<br><strong>Example (using Apollo Client - simplified):</strong></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; ApolloClient, InMemoryCache, gql &#125; from &#x27;@apollo/client&#x27;;</span><br><span class="line"></span><br><span class="line">const client = new ApolloClient(&#123;</span><br><span class="line">  uri: &#x27;/graphql&#x27;,</span><br><span class="line">  cache: new InMemoryCache(),</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.query(&#123;</span><br><span class="line">  query: gql`</span><br><span class="line">    query MyQuery &#123;</span><br><span class="line">      user(id: 123) &#123;</span><br><span class="line">        name</span><br><span class="line">        email</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  `,</span><br><span class="line">&#125;)</span><br><span class="line">.then(result =&gt; console.log(result.data));</span><br></pre></td></tr></table></figure>

<h2 id="Q8-explain-the-grammar-in-the-query-body"><a href="#Q8-explain-the-grammar-in-the-query-body" class="headerlink" title="Q8 explain the grammar in the query body"></a>Q8 explain the grammar in the query body</h2><p>The grammar within the GraphQL query body (the string sent in the “query” field of the JSON request) follows the GraphQL Query Language specification. It’s designed to be human-readable and closely mirrors the structure of the data you want to retrieve.</p>
<p>Here’s a breakdown of the key elements and syntax:</p>
<ol>
<li><p><strong>Operation Type (Optional, but Recommended):</strong> Specifies the type of operation: query, mutation, or subscription. If omitted, it defaults to query.</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query MyQuery &#123; ... &#125;</span><br><span class="line">mutation CreateUser &#123; ... &#125;</span><br><span class="line">subscription NewMessage &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Operation Name (Optional, but Recommended):</strong> Provides a descriptive name for your operation. This is helpful for debugging and when sending multiple operations in a single request.</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query MyQuery &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Selection Set:</strong> The core of a GraphQL query. It defines the fields you want to retrieve from the server. The selection set is enclosed in curly braces {}.</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query MyQuery &#123;</span><br><span class="line">  user(id: 123) &#123;</span><br><span class="line">    name</span><br><span class="line">    email</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Fields:</strong> Represent the data you want to fetch. They correspond to fields defined in the GraphQL schema.</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name</span><br><span class="line">email</span><br><span class="line">posts &#123;</span><br><span class="line">  title</span><br><span class="line">  content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Arguments:</strong> Parameters passed to fields to refine the request. Arguments are enclosed in parentheses ().</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user(id: 123) &#123; ... &#125;</span><br><span class="line">posts(limit: 10, orderBy: &quot;createdAt&quot;) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Nested Objects:</strong> GraphQL allows you to traverse relationships between objects by nesting selection sets.</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">user &#123;</span><br><span class="line">  posts &#123;</span><br><span class="line">    title</span><br><span class="line">    comments &#123;</span><br><span class="line">      text</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Aliases:</strong> Used to rename fields in the response, helpful when fetching the same field multiple times with different arguments.</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  firstUser: user(id: 1) &#123; name &#125;</span><br><span class="line">  secondUser: user(id: 2) &#123; name &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Fragments:</strong> Reusable units of GraphQL code that allow you to select a set of fields from a type. Defined using the fragment keyword.</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fragment UserDetails on User &#123;</span><br><span class="line">  name</span><br><span class="line">  email</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">query MyQuery &#123;</span><br><span class="line">  user(id: 123) &#123;</span><br><span class="line">    ...UserDetails  // Include the fragment</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Variables:</strong> Used to parameterize queries and mutations. Denoted by a $ prefix and defined in the variables object of the JSON request body.</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query MyQuery($userId: ID!) &#123;</span><br><span class="line">  user(id: $userId) &#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Directives:</strong> Modify the execution of the query (e.g., @include, @skip).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query MyQuery($showEmail: Boolean!) &#123;</span><br><span class="line">  user(id: 123) &#123;</span><br><span class="line">    name</span><br><span class="line">    email @include(if: $showEmail)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="Q9-what’s-the-graphQL-schema-include"><a href="#Q9-what’s-the-graphQL-schema-include" class="headerlink" title="Q9 what’s the graphQL schema include"></a>Q9 what’s the graphQL schema include</h2><p>A GraphQL schema is the blueprint for your API. It defines the types of data available, the relationships between them, and the operations clients can perform (queries, mutations, subscriptions). Here’s what a GraphQL schema typically includes:</p>
<ol>
<li><p><strong>Types:</strong></p>
<ul>
<li><p><strong>Scalar Types:</strong> Represent primitive data values. GraphQL has built-in scalar types:</p>
<ul>
<li><p>Int: Integer values.</p>
</li>
<li><p>Float: Floating-point numbers.</p>
</li>
<li><p>String: Text strings.</p>
</li>
<li><p>Boolean: True or false values.</p>
</li>
<li><p>ID: Unique identifiers (often represented as strings).</p>
</li>
</ul>
</li>
<li><p><strong>Object Types:</strong> Represent entities with fields. Each field has a name and a type (which can be another object type, a scalar type, a list, or an enum).</p>
</li>
<li><p><strong>Enum Types:</strong> Define a set of named values.</p>
</li>
<li><p><strong>Interface Types:</strong> Define a common set of fields that object types can implement.</p>
</li>
<li><p><strong>Union Types:</strong> Similar to interfaces but allow an object to be one of several different types.</p>
</li>
<li><p><strong>Input Types:</strong> Used as arguments to mutations, allowing you to pass complex data as input.</p>
</li>
<li><p><strong>List Types:</strong> Represent arrays of values. Denoted by wrapping a type in square brackets (e.g., [String]).</p>
</li>
<li><p><strong>Non-Null Types:</strong> Indicate that a field is required and cannot be null. Denoted by appending an exclamation mark to a type (e.g., String!).</p>
</li>
</ul>
</li>
<li><p><strong>Queries:</strong> Define the read operations clients can perform to fetch data. They specify the arguments that can be passed and the type of data returned.</p>
</li>
<li><p><strong>Mutations:</strong> Define the write operations clients can perform to modify data (create, update, delete). They also specify arguments and return types.</p>
</li>
<li><p><strong>Subscriptions:</strong> Define the real-time operations clients can subscribe to, receiving updates from the server as events occur. They specify the data that will be pushed to the client.</p>
</li>
<li><p><strong>Directives:</strong> (Advanced) Modify the behavior of the schema in various ways. Built-in directives include @deprecated, @skip, and @include. You can also define custom directives.</p>
</li>
</ol>
<p><strong>Example Schema (Illustrative):</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  email: String</span><br><span class="line">  posts: [Post]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Post &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  title: String!</span><br><span class="line">  content: String!</span><br><span class="line">  author: User!</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">  user(id: ID!): User</span><br><span class="line">  posts(authorId: ID): [Post]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Mutation &#123;</span><br><span class="line">  createPost(title: String!, content: String!, authorId: ID!): Post</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Subscription &#123;</span><br><span class="line">  newPost: Post</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>This schema defines User and Post types, a query to fetch users and posts, a mutation to create posts, and a subscription for new posts. It demonstrates the use of different types, including scalars, objects, lists, and non-null types.</p>
<p>The GraphQL schema is crucial because it acts as the contract between the client and the server. Clients can rely on the schema to understand what data is available and how to interact with the API. It also enables features like validation, introspection, and code generation.</p>
<h2 id="Q10-type-Query-vs-type-User"><a href="#Q10-type-Query-vs-type-User" class="headerlink" title="Q10 type Query vs type User"></a>Q10 type Query vs type User</h2><p>In GraphQL, type Query and type User serve distinct but essential roles in defining the schema and how clients can interact with your data. Here’s a breakdown of their differences:</p>
<p><strong>type Query:</strong></p>
<ul>
<li><p><strong>Purpose:</strong> Defines the entry points for reading data from your GraphQL server. It specifies the available queries that clients can execute to fetch data. Think of it as the “read” interface to your data.</p>
</li>
<li><p><strong>Root-Level Type:</strong> type Query is a special root-level type in the GraphQL schema. It’s required for any GraphQL server that supports queries.</p>
</li>
<li><p><strong>Fields as Queries:</strong> The fields within the type Query block represent individual queries. Each field’s name becomes the name of a query that clients can use.</p>
</li>
<li><p><strong>Arguments and Return Types:</strong> Each field within type Query can accept arguments (parameters) and has a specified return type, indicating the shape of the data that the query will return.</p>
</li>
</ul>
<p><strong>Example:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Query &#123;</span><br><span class="line">  user(id: ID!): User  // Query to fetch a single user by ID</span><br><span class="line">  allUsers: [User]    // Query to fetch a list of all users</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>type User:</strong></p>
<ul>
<li><p><strong>Purpose:</strong> Defines a data type representing a user in your application. It describes the structure of a user object, including its fields (properties) and their types.</p>
</li>
<li><p><strong>Regular Object Type:</strong> type User is a regular object type. It’s not a special root-level type like type Query.</p>
</li>
<li><p><strong>Fields as Data Properties:</strong> The fields within type User describe the attributes of a user, such as id, name, email, etc.</p>
</li>
<li><p><strong>Used as Return Types:</strong> type User (or any other object type) is commonly used as the return type of a query field in type Query or even as part of other object types (e.g., a Post type might have an author field of type User).</p>
</li>
</ul>
<p><strong>Key Differences Summarized:</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Feature</td>
<td>type Query</td>
<td>type User</td>
</tr>
<tr>
<td>Purpose</td>
<td>Defines entry points for reading data</td>
<td>Defines a data type (User)</td>
</tr>
<tr>
<td>Type</td>
<td>Root-level type (special)</td>
<td>Regular object type</td>
</tr>
<tr>
<td>Fields</td>
<td>Represent queries</td>
<td>Represent data properties</td>
</tr>
<tr>
<td>Return Types</td>
<td>Specifies data returned by queries</td>
<td>Can be used as a return type</td>
</tr>
</tbody></table>
<p><strong>Relationship:</strong></p>
<p>The type Query and type User (or other object types) work together. The type Query specifies how to access data, and object types like type User define the structure of the data that is returned. The return type of a query field within type Query is often an object type (like User), indicating the shape of the data that the query will produce.</p>
<h2 id="Q11-what’s-the-different-between-the-GraphQL-query-document-and-the-schema-document"><a href="#Q11-what’s-the-different-between-the-GraphQL-query-document-and-the-schema-document" class="headerlink" title="Q11 what’s the different between the GraphQL query document and the schema document"></a>Q11 what’s the different between the GraphQL query document and the schema document</h2><p>The GraphQL schema document and query document serve distinct purposes and have different structures, though they are related. Think of the schema as the blueprint defining what’s possible, and the query as the request specifying what you want.</p>
<p>Here’s a breakdown of their differences:</p>
<p><strong>Schema Document:</strong></p>
<ul>
<li><p><strong>Purpose:</strong> Defines the structure and capabilities of the GraphQL API. It specifies the available types, fields, queries, mutations, and subscriptions. It’s the contract between the client and server.</p>
</li>
<li><p><strong>Structure:</strong> Uses the Schema Definition Language (SDL) to declare types, fields, and operations. It focuses on defining what data can be accessed and how.</p>
</li>
<li><p><strong>Server-Side:</strong> The schema document resides on the server and is used to validate incoming queries and generate documentation.</p>
</li>
<li><p><strong>Example:</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type User &#123;</span><br><span class="line">  id: ID!</span><br><span class="line">  name: String!</span><br><span class="line">  email: String</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Query &#123;</span><br><span class="line">  user(id: ID!): User</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>Query Document:</strong></p>
<ul>
<li><p><strong>Purpose:</strong> Specifies the data a client wants to fetch from the server. It’s a request based on the possibilities defined by the schema.</p>
</li>
<li><p><strong>Structure:</strong> Uses the GraphQL Query Language to request specific fields and operations. It focuses on retrieving data.</p>
</li>
<li><p><strong>Client-Side:</strong> The query document is created and sent by the client as part of an HTTP request.</p>
</li>
<li><p><strong>Example:</strong></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query &#123;</span><br><span class="line">  user(id: 123) &#123;</span><br><span class="line">    name</span><br><span class="line">    email</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>Key Differences Summarized:</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Feature</td>
<td>Schema Document</td>
<td>Query Document</td>
</tr>
<tr>
<td>Purpose</td>
<td>Defines the API</td>
<td>Requests data from the API</td>
</tr>
<tr>
<td>Language</td>
<td>Schema Definition Language (SDL)</td>
<td>GraphQL Query Language</td>
</tr>
<tr>
<td>Location</td>
<td>Server-side</td>
<td>Client-side</td>
</tr>
<tr>
<td>Focus</td>
<td>Definition of data and operations</td>
<td>Retrieval of specific data</td>
</tr>
<tr>
<td>Role</td>
<td>Blueprint&#x2F;Contract</td>
<td>Request&#x2F;Instructions</td>
</tr>
</tbody></table>
<p><strong>Relationship:</strong></p>
<p>The query document must be valid according to the schema document. The server uses the schema to validate incoming queries, ensuring that they request only existing fields and types. The schema acts as a guide for constructing valid queries, guaranteeing that the client can only request what the server is capable of providing. The schema is like a restaurant menu, and the query is like the customer’s order – the customer can only order what’s on the menu.</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/AI/" rel="tag"># AI</a>
              <a href="/tags/GraphQL/" rel="tag"># GraphQL</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/posts/f7dab9e4/" rel="prev" title="一个安卓老项目重构计划">
                  <i class="fa fa-angle-left"></i> 一个安卓老项目重构计划
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/posts/b6e04f0f/" rel="next" title="Quick read paging3 source code by AI tool">
                  Quick read paging3 source code by AI tool <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">gnehz972</span>
  </div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  

  <script class="next-config" data-name="mermaid" type="application/json">{"enable":true,"theme":{"light":"default","dark":"dark"},"js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mermaid/11.4.0/mermaid.min.js","integrity":"sha256-G8ouPAnw4zzMbnAenHnVz6h9XpKbNdOkrqTh7AadyHs="}}</script>
  <script src="/js/third-party/tags/mermaid.js"></script>





  





</body>
</html>
